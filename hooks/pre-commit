#!/usr/bin/env bash
# Living Documentation Framework - Pre-Commit Hook
# Validates documentation requirements before allowing commit

set -e

# =============================================================================
# BASH VERSION CHECK
# Associative arrays (declare -A) require Bash 4.0+
# =============================================================================
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    echo "ERROR: Bash 4.0+ required (you have $BASH_VERSION)"
    echo ""
    echo "How to fix:"
    echo "  macOS:   brew install bash"
    echo "  Windows: Use Git Bash (bundled with Git for Windows)"
    echo "  Linux:   Usually already 4.0+, check with: bash --version"
    echo ""
    echo "Skipping documentation checks (commit allowed)."
    exit 0
fi

# Get project root (where .git is)
PROJECT_ROOT=$(git rev-parse --show-toplevel)

# Load configuration
FRAMEWORK_HOOKS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FRAMEWORK_ROOT="$(cd "$FRAMEWORK_HOOKS_DIR/.." && pwd)"

if [ -f "$FRAMEWORK_ROOT/core/load-config.sh" ]; then
    source "$FRAMEWORK_ROOT/core/load-config.sh"
else
    echo "Warning: Configuration loader not found"
    echo "Skipping documentation checks"
    exit 0
fi

# Colors for output (check terminal support) - defined early for use in functions
if [ -t 1 ]; then
    RED='\033[0;31m'
    YELLOW='\033[1;33m'
    GREEN='\033[0;32m'
    NC='\033[0m'
else
    RED=''
    YELLOW=''
    GREEN=''
    NC=''
fi

# Build regex pattern for code file extensions
# Supports: LDF_CODE_EXTS (comma-separated: "js,ts,jsx") or LDF_CODE_EXT (single: "py")
build_ext_pattern() {
    local exts="${LDF_CODE_EXTS:-$LDF_CODE_EXT}"
    # Default to "py" if somehow empty (prevents invalid regex)
    exts="${exts:-py}"
    # Convert "js,ts,jsx" to "js|ts|jsx" for regex alternation
    echo "$exts" | tr ',' '|'
}
CODE_EXT_PATTERN=$(build_ext_pattern)

# =============================================================================
# DOC-SET DISCOVERY FUNCTIONS
# A "doc-set" is any folder containing CODE_DOC_MAP.md
# =============================================================================

# Check if a file is listed as Tier A in any CODE_DOC_MAP.md
# Returns: path to the CODE_DOC_MAP.md that lists it, or empty
#
# MATCHING RULES:
# 1. Requires TIER A token on the SAME LINE as the file path (prevents false positives)
# 2. Uses repo-relative paths only (no basename fallback - deterministic matching)
# 3. Two-stage matching: grep for "tier a", then fixed-string match for file path
#    (avoids regex issues with special characters in paths like . + [ ] etc.)
find_tier_a_map_for_file() {
    local file="$1"

    # Use while-read pattern to handle spaces in paths
    while IFS= read -r map; do
        # Two-stage match: find lines with "tier a", then check for exact file path
        # -F = fixed-string (no regex interpretation of file path)
        if grep -i "tier a" "$map" 2>/dev/null | grep -Fq "\`$file\`"; then
            echo "$map"
            return 0
        fi
    done < <(find "$PROJECT_ROOT/docs" -name "CODE_DOC_MAP.md" 2>/dev/null)

    # Backward compat: root-level CODE_DOC_MAP.md (DEPRECATED - emit warning)
    if [ -f "$PROJECT_ROOT/CODE_DOC_MAP.md" ]; then
        if grep -i "tier a" "$PROJECT_ROOT/CODE_DOC_MAP.md" 2>/dev/null | grep -Fq "\`$file\`"; then
            echo -e "${YELLOW}Warning: Using deprecated root CODE_DOC_MAP.md${NC}" >&2
            echo -e "${YELLOW}  â†’ Migrate to docs/<subsystem>/CODE_DOC_MAP.md${NC}" >&2
            echo "$PROJECT_ROOT/CODE_DOC_MAP.md"
            return 0
        fi
    fi

    return 1
}

# Get sibling INVARIANTS.md path for a CODE_DOC_MAP.md
get_sibling_invariants() {
    local map="$1"
    local dir=$(dirname "$map")
    echo "$dir/INVARIANTS.md"
}

# Detect file listed in multiple CODE_DOC_MAPs (MUST NOT happen)
check_tier_a_conflicts() {
    local file="$1"
    local maps_found=0
    local found_maps=""

    while IFS= read -r map; do
        # Two-stage match: find lines with "tier a", then check for exact file path
        if grep -i "tier a" "$map" 2>/dev/null | grep -Fq "\`$file\`"; then
            maps_found=$((maps_found + 1))
            found_maps="$found_maps $map"
        fi
    done < <(find "$PROJECT_ROOT/docs" -name "CODE_DOC_MAP.md" 2>/dev/null)

    if [ "$maps_found" -gt 1 ]; then
        echo -e "${RED}ERROR: Tier A conflict - file listed in multiple CODE_DOC_MAPs${NC}"
        echo "   File: $file"
        echo "   Maps:$found_maps"
        echo ""
        echo "   Rule: A code file must belong to exactly ONE doc-set."
        echo "   Fix: Remove from all but one map, or move to docs/global/CODE_DOC_MAP.md"
        return 1
    fi
    return 0
}

# Check that sibling INVARIANTS.md exists
check_invariants_exists() {
    local invariants_path="$1"

    if [ ! -f "$invariants_path" ]; then
        echo -e "${RED}ERROR: Required file missing${NC}"
        echo "   Missing: ${invariants_path#$PROJECT_ROOT/}"
        echo ""
        echo "   This doc-set requires INVARIANTS.md for Tier A enforcement."
        echo "   Create it with: touch ${invariants_path#$PROJECT_ROOT/}"
        return 1
    fi
    return 0
}

echo -e "${GREEN}Living Documentation - Pre-Commit Validation${NC}"
echo ""

# Get list of changed files
CHANGED_FILES=$(git diff --cached --name-only)

if [ -z "$CHANGED_FILES" ]; then
    echo "No files staged for commit"
    exit 0
fi

# Count files (handle empty case - echo "" | wc -l returns 1, not 0)
if [ -z "$CHANGED_FILES" ]; then
    FILE_COUNT=0
else
    FILE_COUNT=$(echo "$CHANGED_FILES" | wc -l)
fi
echo "Files staged: $FILE_COUNT"
echo ""

# ============================================================================
# CHECK 1: Blast Radius Warning
# ============================================================================
BLAST_THRESHOLD="${LDF_BLAST_THRESHOLD:-5}"
if [ "$FILE_COUNT" -gt "$BLAST_THRESHOLD" ]; then
    echo -e "${YELLOW}BLAST RADIUS WARNING${NC}"
    echo "   Large change detected: $FILE_COUNT files"
    echo "   Consider splitting into smaller commits"
    echo ""
fi

# ============================================================================
# CHECK 2: Changelog Updated
# ============================================================================
# Match any configured code extension (supports multiple: js,ts,jsx)
CODE_CHANGED=$(echo "$CHANGED_FILES" | grep -E "\.($CODE_EXT_PATTERN)$" | wc -l || echo "0")

if [ "$CODE_CHANGED" -gt 0 ]; then
    CHANGELOG_UPDATED=$(echo "$CHANGED_FILES" | grep -c "CHANGELOG" || echo "0")

    if [ "$CHANGELOG_UPDATED" -eq 0 ]; then
        echo -e "${YELLOW}CHANGELOG NOT UPDATED${NC}"
        echo "   Code files changed but CHANGELOG.md not updated"
        echo "   Consider adding an entry to track this change"
        echo ""
    fi
fi

# ============================================================================
# CHECK 3: Tier A File Validation (Doc-Set Aware)
# Scans all docs/*/CODE_DOC_MAP.md files and root CODE_DOC_MAP.md (deprecated)
# ============================================================================
TIER_A_ERRORS=0
declare -A REQUIRED_INVARIANTS  # map path -> 1

while IFS= read -r file; do
    if [ -z "$file" ]; then continue; fi

    # Skip non-code files (supports multiple extensions)
    if ! echo "$file" | grep -qE "\.($CODE_EXT_PATTERN)$"; then continue; fi

    # Check for conflicts FIRST (file in multiple maps)
    if ! check_tier_a_conflicts "$file"; then
        TIER_A_ERRORS=$((TIER_A_ERRORS + 1))
        continue
    fi

    # Find which CODE_DOC_MAP.md (if any) lists this file as Tier A
    tier_a_map=$(find_tier_a_map_for_file "$file")

    if [ -n "$tier_a_map" ]; then
        # File is Tier A - require sibling INVARIANTS.md update
        invariants_path=$(get_sibling_invariants "$tier_a_map")
        rel_invariants="${invariants_path#$PROJECT_ROOT/}"
        REQUIRED_INVARIANTS["$rel_invariants"]=1

        echo -e "${YELLOW}Tier A: $file${NC}"
        echo "   Mapped in: ${tier_a_map#$PROJECT_ROOT/}"
        echo "   Requires:  $rel_invariants"
    fi
done <<< "$CHANGED_FILES"

# Check that all required INVARIANTS.md files EXIST and are UPDATED
for invariants_path in "${!REQUIRED_INVARIANTS[@]}"; do
    # Step 1: Check file exists (hard fail if missing)
    if ! check_invariants_exists "$PROJECT_ROOT/$invariants_path"; then
        TIER_A_ERRORS=$((TIER_A_ERRORS + 1))
        continue
    fi

    # Step 2: Check file was updated in this commit
    # Use -F for fixed-string (paths may contain regex special chars)
    if ! echo "$CHANGED_FILES" | grep -Fq "$invariants_path"; then
        echo ""
        echo -e "${RED}ERROR: Tier A file changed but INVARIANTS not updated${NC}"
        echo "   Missing update: $invariants_path"
        echo ""
        echo "   Please:"
        echo "     1. Read the invariants in $invariants_path"
        echo "     2. Cite which invariants you're respecting"
        echo "     3. Add new invariants if needed"
        echo ""
        echo "   To skip (emergency only): git commit --no-verify"
        TIER_A_ERRORS=$((TIER_A_ERRORS + 1))
    fi
done

if [ "$TIER_A_ERRORS" -gt 0 ]; then
    exit 1
fi

# ============================================================================
# CHECK 4: Version Consistency (if version file exists)
# ============================================================================
if [ -f "$PROJECT_ROOT/$LDF_VERSION_FILE" ] && [ -f "$PROJECT_ROOT/$LDF_CHANGELOG" ]; then
    # Extract version using grep -o (portable) instead of grep -P
    FILE_VERSION=$(grep -oE '[0-9]+\.[0-9]+\.[0-9]+' "$PROJECT_ROOT/$LDF_VERSION_FILE" 2>/dev/null | head -1 || echo "")

    CHANGELOG_VERSION=$(grep -m1 "^## \[" "$PROJECT_ROOT/$LDF_CHANGELOG" | sed 's/## \[\([^]]*\)\].*/\1/' || echo "")

    if [ -n "$FILE_VERSION" ] && [ -n "$CHANGELOG_VERSION" ]; then
        if [ "$FILE_VERSION" != "$CHANGELOG_VERSION" ]; then
            echo -e "${RED}ERROR: Version mismatch${NC}"
            echo "   $LDF_VERSION_FILE:  $FILE_VERSION"
            echo "   CHANGELOG.md:       $CHANGELOG_VERSION"
            echo ""
            echo "   Please sync versions before committing"
            exit 1
        fi
    fi
fi

# ============================================================================
# SUCCESS
# ============================================================================
echo -e "${GREEN}Pre-commit checks passed${NC}"
echo ""

exit 0
